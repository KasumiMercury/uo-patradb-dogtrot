// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/KasumiMercury/uo-patradb-dogtrot/ent/description"
	"github.com/KasumiMercury/uo-patradb-dogtrot/ent/video"
)

// Video is the model entity for the Video schema.
type Video struct {
	config `json:"-"`
	// ID of the ent.
	ID string `json:"id,omitempty"`
	// SourceID holds the value of the "source_id" field.
	SourceID string `json:"source_id,omitempty"`
	// Title holds the value of the "title" field.
	Title string `json:"title,omitempty"`
	// DurationSeconds holds the value of the "duration_seconds" field.
	DurationSeconds int `json:"duration_seconds,omitempty"`
	// IsCollaboration holds the value of the "is_collaboration" field.
	IsCollaboration bool `json:"is_collaboration,omitempty"`
	// Status holds the value of the "status" field.
	Status string `json:"status,omitempty"`
	// ChatID holds the value of the "chat_id" field.
	ChatID string `json:"chat_id,omitempty"`
	// HasTimeRange holds the value of the "has_time_range" field.
	HasTimeRange bool `json:"has_time_range,omitempty"`
	// CapturePermission holds the value of the "capture_permission" field.
	CapturePermission bool `json:"capture_permission,omitempty"`
	// ScheduledAt holds the value of the "scheduled_at" field.
	ScheduledAt time.Time `json:"scheduled_at,omitempty"`
	// ActualStartAt holds the value of the "actual_start_at" field.
	ActualStartAt time.Time `json:"actual_start_at,omitempty"`
	// ActualEndAt holds the value of the "actual_end_at" field.
	ActualEndAt time.Time `json:"actual_end_at,omitempty"`
	// PublishedAt holds the value of the "published_at" field.
	PublishedAt time.Time `json:"published_at,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the VideoQuery when eager-loading is set.
	Edges        VideoEdges `json:"edges"`
	selectValues sql.SelectValues
}

// VideoEdges holds the relations/edges for other nodes in the graph.
type VideoEdges struct {
	// Descriptions holds the value of the descriptions edge.
	Descriptions *Description `json:"descriptions,omitempty"`
	// Channel holds the value of the channel edge.
	Channel []*Channel `json:"channel,omitempty"`
	// VideoPlayRanges holds the value of the video_play_ranges edge.
	VideoPlayRanges []*VideoPlayRange `json:"video_play_ranges,omitempty"`
	// VideoDisallowRanges holds the value of the video_disallow_ranges edge.
	VideoDisallowRanges []*VideoDisallowRange `json:"video_disallow_ranges,omitempty"`
	// VideoTitleChanges holds the value of the video_title_changes edge.
	VideoTitleChanges []*VideoTitleChange `json:"video_title_changes,omitempty"`
	// PatChats holds the value of the pat_chats edge.
	PatChats []*PatChat `json:"pat_chats,omitempty"`
	// VideoTags holds the value of the video_tags edge.
	VideoTags []*VideoTag `json:"video_tags,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [7]bool
}

// DescriptionsOrErr returns the Descriptions value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e VideoEdges) DescriptionsOrErr() (*Description, error) {
	if e.loadedTypes[0] {
		if e.Descriptions == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: description.Label}
		}
		return e.Descriptions, nil
	}
	return nil, &NotLoadedError{edge: "descriptions"}
}

// ChannelOrErr returns the Channel value or an error if the edge
// was not loaded in eager-loading.
func (e VideoEdges) ChannelOrErr() ([]*Channel, error) {
	if e.loadedTypes[1] {
		return e.Channel, nil
	}
	return nil, &NotLoadedError{edge: "channel"}
}

// VideoPlayRangesOrErr returns the VideoPlayRanges value or an error if the edge
// was not loaded in eager-loading.
func (e VideoEdges) VideoPlayRangesOrErr() ([]*VideoPlayRange, error) {
	if e.loadedTypes[2] {
		return e.VideoPlayRanges, nil
	}
	return nil, &NotLoadedError{edge: "video_play_ranges"}
}

// VideoDisallowRangesOrErr returns the VideoDisallowRanges value or an error if the edge
// was not loaded in eager-loading.
func (e VideoEdges) VideoDisallowRangesOrErr() ([]*VideoDisallowRange, error) {
	if e.loadedTypes[3] {
		return e.VideoDisallowRanges, nil
	}
	return nil, &NotLoadedError{edge: "video_disallow_ranges"}
}

// VideoTitleChangesOrErr returns the VideoTitleChanges value or an error if the edge
// was not loaded in eager-loading.
func (e VideoEdges) VideoTitleChangesOrErr() ([]*VideoTitleChange, error) {
	if e.loadedTypes[4] {
		return e.VideoTitleChanges, nil
	}
	return nil, &NotLoadedError{edge: "video_title_changes"}
}

// PatChatsOrErr returns the PatChats value or an error if the edge
// was not loaded in eager-loading.
func (e VideoEdges) PatChatsOrErr() ([]*PatChat, error) {
	if e.loadedTypes[5] {
		return e.PatChats, nil
	}
	return nil, &NotLoadedError{edge: "pat_chats"}
}

// VideoTagsOrErr returns the VideoTags value or an error if the edge
// was not loaded in eager-loading.
func (e VideoEdges) VideoTagsOrErr() ([]*VideoTag, error) {
	if e.loadedTypes[6] {
		return e.VideoTags, nil
	}
	return nil, &NotLoadedError{edge: "video_tags"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Video) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case video.FieldIsCollaboration, video.FieldHasTimeRange, video.FieldCapturePermission:
			values[i] = new(sql.NullBool)
		case video.FieldDurationSeconds:
			values[i] = new(sql.NullInt64)
		case video.FieldID, video.FieldSourceID, video.FieldTitle, video.FieldStatus, video.FieldChatID:
			values[i] = new(sql.NullString)
		case video.FieldScheduledAt, video.FieldActualStartAt, video.FieldActualEndAt, video.FieldPublishedAt, video.FieldCreatedAt, video.FieldUpdatedAt:
			values[i] = new(sql.NullTime)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Video fields.
func (v *Video) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case video.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				v.ID = value.String
			}
		case video.FieldSourceID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field source_id", values[i])
			} else if value.Valid {
				v.SourceID = value.String
			}
		case video.FieldTitle:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field title", values[i])
			} else if value.Valid {
				v.Title = value.String
			}
		case video.FieldDurationSeconds:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field duration_seconds", values[i])
			} else if value.Valid {
				v.DurationSeconds = int(value.Int64)
			}
		case video.FieldIsCollaboration:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field is_collaboration", values[i])
			} else if value.Valid {
				v.IsCollaboration = value.Bool
			}
		case video.FieldStatus:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field status", values[i])
			} else if value.Valid {
				v.Status = value.String
			}
		case video.FieldChatID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field chat_id", values[i])
			} else if value.Valid {
				v.ChatID = value.String
			}
		case video.FieldHasTimeRange:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field has_time_range", values[i])
			} else if value.Valid {
				v.HasTimeRange = value.Bool
			}
		case video.FieldCapturePermission:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field capture_permission", values[i])
			} else if value.Valid {
				v.CapturePermission = value.Bool
			}
		case video.FieldScheduledAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field scheduled_at", values[i])
			} else if value.Valid {
				v.ScheduledAt = value.Time
			}
		case video.FieldActualStartAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field actual_start_at", values[i])
			} else if value.Valid {
				v.ActualStartAt = value.Time
			}
		case video.FieldActualEndAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field actual_end_at", values[i])
			} else if value.Valid {
				v.ActualEndAt = value.Time
			}
		case video.FieldPublishedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field published_at", values[i])
			} else if value.Valid {
				v.PublishedAt = value.Time
			}
		case video.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				v.CreatedAt = value.Time
			}
		case video.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				v.UpdatedAt = value.Time
			}
		default:
			v.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Video.
// This includes values selected through modifiers, order, etc.
func (v *Video) Value(name string) (ent.Value, error) {
	return v.selectValues.Get(name)
}

// QueryDescriptions queries the "descriptions" edge of the Video entity.
func (v *Video) QueryDescriptions() *DescriptionQuery {
	return NewVideoClient(v.config).QueryDescriptions(v)
}

// QueryChannel queries the "channel" edge of the Video entity.
func (v *Video) QueryChannel() *ChannelQuery {
	return NewVideoClient(v.config).QueryChannel(v)
}

// QueryVideoPlayRanges queries the "video_play_ranges" edge of the Video entity.
func (v *Video) QueryVideoPlayRanges() *VideoPlayRangeQuery {
	return NewVideoClient(v.config).QueryVideoPlayRanges(v)
}

// QueryVideoDisallowRanges queries the "video_disallow_ranges" edge of the Video entity.
func (v *Video) QueryVideoDisallowRanges() *VideoDisallowRangeQuery {
	return NewVideoClient(v.config).QueryVideoDisallowRanges(v)
}

// QueryVideoTitleChanges queries the "video_title_changes" edge of the Video entity.
func (v *Video) QueryVideoTitleChanges() *VideoTitleChangeQuery {
	return NewVideoClient(v.config).QueryVideoTitleChanges(v)
}

// QueryPatChats queries the "pat_chats" edge of the Video entity.
func (v *Video) QueryPatChats() *PatChatQuery {
	return NewVideoClient(v.config).QueryPatChats(v)
}

// QueryVideoTags queries the "video_tags" edge of the Video entity.
func (v *Video) QueryVideoTags() *VideoTagQuery {
	return NewVideoClient(v.config).QueryVideoTags(v)
}

// Update returns a builder for updating this Video.
// Note that you need to call Video.Unwrap() before calling this method if this Video
// was returned from a transaction, and the transaction was committed or rolled back.
func (v *Video) Update() *VideoUpdateOne {
	return NewVideoClient(v.config).UpdateOne(v)
}

// Unwrap unwraps the Video entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (v *Video) Unwrap() *Video {
	_tx, ok := v.config.driver.(*txDriver)
	if !ok {
		panic("ent: Video is not a transactional entity")
	}
	v.config.driver = _tx.drv
	return v
}

// String implements the fmt.Stringer.
func (v *Video) String() string {
	var builder strings.Builder
	builder.WriteString("Video(")
	builder.WriteString(fmt.Sprintf("id=%v, ", v.ID))
	builder.WriteString("source_id=")
	builder.WriteString(v.SourceID)
	builder.WriteString(", ")
	builder.WriteString("title=")
	builder.WriteString(v.Title)
	builder.WriteString(", ")
	builder.WriteString("duration_seconds=")
	builder.WriteString(fmt.Sprintf("%v", v.DurationSeconds))
	builder.WriteString(", ")
	builder.WriteString("is_collaboration=")
	builder.WriteString(fmt.Sprintf("%v", v.IsCollaboration))
	builder.WriteString(", ")
	builder.WriteString("status=")
	builder.WriteString(v.Status)
	builder.WriteString(", ")
	builder.WriteString("chat_id=")
	builder.WriteString(v.ChatID)
	builder.WriteString(", ")
	builder.WriteString("has_time_range=")
	builder.WriteString(fmt.Sprintf("%v", v.HasTimeRange))
	builder.WriteString(", ")
	builder.WriteString("capture_permission=")
	builder.WriteString(fmt.Sprintf("%v", v.CapturePermission))
	builder.WriteString(", ")
	builder.WriteString("scheduled_at=")
	builder.WriteString(v.ScheduledAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("actual_start_at=")
	builder.WriteString(v.ActualStartAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("actual_end_at=")
	builder.WriteString(v.ActualEndAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("published_at=")
	builder.WriteString(v.PublishedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("created_at=")
	builder.WriteString(v.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(v.UpdatedAt.Format(time.ANSIC))
	builder.WriteByte(')')
	return builder.String()
}

// Videos is a parsable slice of Video.
type Videos []*Video
